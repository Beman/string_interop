<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Unicode White Paper</title>
<style type="text/css">
 ins {background-color:#A0FFA0}
 del {background-color:#FFA0A0}
</style>
</head>

<body>

<h1>Proposal for Improved String Interoperability in a Unicode World <span style="background-color: #FFFF00">(DRAFT)</span></h1>

<h2>Introduction</h2>

<p>This paper proposes additions to Boost and the C++11 standard library to ease use of strings 
in an international environment. The primary focus is making the Unicode 
features of C++11 easier to use, although other character encodings are also 
supported.</p>

<p>The proposal is for pure additions to Boost and the C++ standard library. No C++03 
or C++11 compliant code is broken or otherwise affected by the additions.</p>

<h2>Motivation</h2>

<p>The motivation for this proposal is a series of frustrations. These 
frustrations were originally encountered while 
providing Unicode string support for the internationalization of commercial GIS software. 
They appeared again while working on the 
Boost Filesystem Library. These frustrations have become much worse as compiler 
support for C++11's additional Unicode support makes it easier to write programs 
that run up against current limitations.</p>

<p>The frustrations fall into several categories:</p>

<h3>Strings of different character types do not interoperate</h3>

<h3>I/O streams do not accept strings of different character types </h3>

<p>A &quot;Hello World&quot; program using a C++11 Unicode string literal illustrates 
this 
frustration:</p>

<blockquote>
  <pre>#include &lt;iostream&gt;
int main()
{
  std::cout &lt;&lt; U&quot;&#24744;&#22909;&#19990;&#30028;&quot;;   // error in C++11!
}</pre>
</blockquote>

<h3>Conversion between string types and encodings is awkward</h3>

<p>Frustrations revolve around <code>std::codecvt</code>, <code>std::locale</code>, 
<code>std::wstring_convert</code>, and other standard library conversion facilities:</p>
<ul>
  <li>Given <b><i>n</i></b> encodings, necessity of 
  providing <b>n<sup>2</sup></b> <code>codecvt</code> facets rather than <b>2n</b> codecs. 
  UTF-32 is the obvious choice for the common encoding to pass between codecs. 
  This is existing practice in C libraries like ICU.</li>
  <li>Interfaces don't work well with generic programming 
  techniques, particularly iterators.</li>
  <li>Unnecessary creation of temporary strings, with 
  attendant memory allocations/deallocations.</li>
  <li>Complex, difficult to learn, and difficult to use <code>std::codecvt</code> interfaces.</li>
  <li>Intertwining of <code>std::locale</code> and code conversion, even when these 
  are implementation details that should be hidden from the application.</li>
  <li>Difficult to control error actions. Choices should include:<ul>
  <li>Throw exception.</li>
  <li>Replace offending character with default character. </li>
  <li>Replace offending character with specified character. Motivating example: 
  Filesystem's need to use a replacement character that is acceptable to the 
  Windows codepage. See Boost issue #5769.</li>
  </ul>
  </li>
  </ul>

<h2>Proof-of-concept implementation</h2>

<p>A &quot;proof-of-concept&quot; implementation of the solutions presented here is 
available at <a href="https://github.com/Beman/string-interoperability">
https://github.com/Beman/string-interoperability</a>.</p>

<h2>Technical inspiration</h2>

<p>Peter Dimov inspired the idea of string interoperability by arguing that the 
Boost Filesystem library should treat a path is a single 
  type (i.e. not a template) regardless of the character size 
  and encoding of the source and target strings.</p>

<p>John Maddock's Unicode conversion iterators demonstrated an 
  easier-to-use, more efficient, and STL friendlier way to perform character 
type and encoding conversions as an alternative to standard library <code>
codecvt</code> facets.</p>

<p>C++11 provides the underlying language and library features that allow string 
interoperability:</p>

<ul>
  <li><code>char16_t</code> and <code>char_32_t</code>&nbsp; provide Unicode 
  character types and null-terminated characters strings with guaranteed 
  encodings.</li>
  <li><code>std::u16string</code> and <code>std::u32string</code> provide 
  library support for Unicode character types and encodings.</li>
  <li><code>u</code> and <code>U</code> character and string literals ease 
  programming with Unicode character types and encodings.</li>
</ul>

<h3>Not addressed</h3>

<p>The proposed additions deal with C++11 <code>std::basic_string</code> and 
character types, and with their encodings. The deeper attributes of Unicode 
characters are not addressed. See Mathias Gaunard's <a href="http://mathias.gaunard.com/unicode/doc/html/">
  Unicode project</a> for an example of deeper Unicode support.</p>

<h3>The cat is out of the bag</h3>

<h3>String interoperability</h3>

<h3>Standard algorithms and other functions taking iterator arguments</h3>
<h3 dir="ltr">Functions taking const <i>character-type</i>* arguments</h3>
<h3 dir="ltr">Functions taking const <i>string-type</i>&amp; arguments</h3>

<h3 dir="ltr">Function templates taking character iterator arguments</h3>

<h3 dir="ltr">Function templates taking const <i>string-type</i>&amp; arguments</h3>

<h2>Frustration 1: A <code>basic_string</code> instantiation does not interoperate 
with different <code>basic_string</code> instantiations</h2>

<h3>Examples</h3>
<blockquote>
  <pre>u32string s32;
s32 = &quot;foo&quot;;         // error!
u16string s16(s32);  // error!
wstring ws(s32.begin(), s32.end()); // error!</pre>
  <pre>void f(const string&amp;);</pre>
  <pre>f(s32);  //error!</pre>
</blockquote>
<p>The encoding of basic_string instantiations can be determined for 
the types under discussion. It is either implicit in the string's value_type or 
can be determined via the locale.&nbsp; See Boost.Filesystem V3 class path for 
an example of how such interoperability might be achieved.</p>
<p>Experience with Boost.Filesystem V3 class path has demonstrated 
that string interoperability brings a considerable simplification and 
improvement to internationalized applications, but that having to provide 
interoperability without the resolution of the issues presented here is a 
band-aid. It is being misused, too - users are passing around boost::filesystem::path objects simply to get string encoding interoperability!</p>
<p>Note: interoperability will be easier to specify, implement, and 
use if Issue 4 is resolved.</p>

<h3>Proposed resolution</h3>

<blockquote>

<p>Boost resolution????: Provide namespace boost string classes that derived 
from std::basic_string and add the additional functions necessary to provide as 
much interoperability as possible without breaking existing code if substituted 
for existing uses of std::basic_string.</p>

<p>Standard library resolution????: Add additional std::basic_string function 
overloadss 
as necessary to provide as much interoperability as possible without breaking 
existing code if substituted for existing uses of std::basic_string.</p>
</blockquote>
<h2>Frustration 2: A <code>basic_string</code> instantiation does not interoperate 
with null-terminated character strings other than of its <code>value_type</code></h2>
<h2>Frustration 3: A <code>basic_string</code> instantiation does not interoperate 
with I/O streams other than of its <code>value_type</code></h2>
<h3>Motivating example</h3>

<blockquote>
  <pre>int main()
{
  std::cout &lt;&lt; U&quot;&#24744;&#22909;&#19990;&#30028;&quot;;   // error in C++11!
}</pre>
</blockquote>
<p>This code should 
&quot;just work&quot;, even though the type of <code>U&quot;&#24744;&#22909;&#19990;&#30028;&quot;</code> is <code>const 
char32_t*</code>, not <code>const char*</code>, as long as the encoding of <code>char</code> 
supports &#24744;&#22909;&#19990;&#30028;. </p>
<p>It does &quot;just work&quot; with the proof-of-concept implementation of this 
proposal. On Linux, with default <code>char</code> encoding of UTF-8,  execution 
produces the expected &#24744;&#22909;&#19990;&#30028; output. On Windows, the 
console doesn't support full UTF-8, so the output can be piped to a file or to a 
program which does handle UTF-8 correctly.</p>

<h2>Frustration 4: Conversion between character encodings is awkward</h2>
<p>Concerns revolve around std::codecvt, std::locale, 
std::wstring_convert, and other standard library conversion facilities:</p>
<ul>
  <li>Given <b><i>n</i></b> encodings, necessity of 
  providing <b>n<sup>2</sup></b> codecvt facets rather than <b>2n</b> codecs. 
  UTF-32 is the obvious choice for the common encoding to pass between codecs. 
  This is existing practice in C libraries like ICU.</li>
  <li>Interfaces don't work well with generic programming 
  techniques.</li>
  <li>Unnecessary creation of temporary strings, with 
  attendant memory allocations/deallocations.</li>
  <li>Complex, difficult to learn, and difficult to use std::codecvt interfaces.</li>
  <li>Intertwining of std::locale and code conversion, even when these 
  are implementation details that should be hidden from the application.</li>
  <li>Difficult to control error actions. Choices should include:<ul>
  <li>Throw exception.</li>
  <li>Replace offending character with default character. </li>
  <li>Replace offending character with specified character. Motivating example: 
  Filesystem's need to use a replacement character that is acceptable to the 
  Windows codepage. See Boost issue #5769.</li>
  </ul>
  </li>
  </ul>
<h3>Proposed resolution</h3>
<blockquote>
<p>Provide a boost library header inspired by the iterator adaptor approach to 
encoding conversion pioneered by John Maddock in boost/regex/pending/unicode_iterator.hpp:</p>
  <ul>
    <li>from_<b><i>X</i></b> and to_<i><b>X</b></i> iterator adaptor codecs to 
    and from UTF-32. Possibly implemented using ICU iterators for the less 
    common encodings.</li>
    <li>General composition support for combining a from_<b><i>X</i></b> and to_<b><i>X</i></b> 
    into a complete conversion adaptor.</li>
    <li>Specializations or overloads prepackaging the 25 char, wchar_t, char8_t, 
    char16_t, and char32_t complete conversion adaptors.</li>
  </ul>
</blockquote>
<<<<<<< HEAD
=======
<h2>Frustration 5: String type interoperability requires an excessive number of 
overloads</h2>
<p>Overloads or specializations are required for:</p>
<blockquote>
  <ul>
    <li>Other instances of the same type.</li>
    <li>Single characters.</li>
    <li>Single iterators to terminated strings.</li>
    <li>Single iterators to strings whose size is determined by a size argument.</li>
    <li>Iterator ranges.</li>
    <li>Further variations on the above, with additional arguments for position 
    or repeat count.</li>
  </ul>
</blockquote>
<p>Each of these then have to be repeated in template form for interoperability 
with other string types.</p>
<h2>Frustration ?: Missing UTF-8 character type</h2>

<p>There is no built-in character type that specifies UTF-8 encoding. Without 
such a type, neither template arguments nor function overloads have a way to 
specify a narrow character with UTF-8 encoding. This is a confusing 
inconsistency with char16_t and char32_t. It sends the message to users that 
UTF-8 encoding is a second class citizen of the C++ world.</p>

<p>Just as character types <code>char16_t</code> and <code>char32_t</code> 
provide the foundation for <code>u16string</code> and <code>u32string</code>, a 
character type for 8-bit UTF-8 encoded characters is required as the foundation 
for solutions to the other issues presented here.</p>

<h3>Proposed resolution</h3>

<p dir="ltr">Because type <code>unsigned char</code> is distinct from type <code>
char</code>, it can be hijacked as the UTF-8 encoded character type. The 
proof-of-concept implementation does this and it has been problem free.</p>

<h4 dir="ltr">C++ committee:</h4>

<blockquote>

<p dir="ltr">Option 1:&nbsp; Add a new character type <code>char8_t</code> 
specified to have UTF-8 encoding.</p>

<p>Option 2:&nbsp; Add a global namespace <code>typedef unsigned char char8_t;</code> 
to standard library headers dealing with characters.</p>

</blockquote>

<h4>Boost:</h4>

<blockquote>

<p>Assuming <code>boost::u16_t</code> and <code>boost::u32_t</code> are the 
Boost types for <code>char16_t</code> and <code>char32_t</code>, add:</p>

  <blockquote>
    <pre>namespace boost
{
  <code>typedef unsigned char  u8_t;
}</code></pre>
  </blockquote>
</blockquote>

<h2>Frustration ?: Missing UTF-8 string type</h2>

<p dir="ltr">There is no string type that specifies UTF-8 encoding. Without such 
a type, neither template arguments nor function overloads have a way to specify 
a narrow character string with UTF-8 encoding.</p>

<h3>Proposed resolution</h3>

<p>Provide:</p>
<blockquote>

<pre dir="ltr">namespace boost
{
  typedef std::basic_string&lt;boost::char8&gt; u8string;
}</pre>
</blockquote>

<h2>Proposed Resolution</h2>
<h3>Additions to class std::basic_string</h3>
<p>For each constructor, <code>operator=</code>, <code>operator+=</code>, <code>
append</code>, and <code>assign</code> signature, add a function template with a 
template parameter for the signature's string argument type, character argument 
type, or iterator argument type, as appropriate. The added functions shall not 
participate in overload resolution if the value type of the template parameter 
is the same as <code>basic_string::value_type</code>.&nbsp; The semantics of the 
added signatures are the same as original signatures except that arguments of 
the template parameter type shall be converted to the type and encoding of <code>
basic_string::value_type</code>.</p>
<p>For <code>c_str</code> (and possibly <code>begin</code> and <code>end</code>), 
add a function template of the same name with a template parameter specifying a 
character type. The return type shall be an unspecified constant iterator whose 
value type is the template parameter character type.</p>
<p>For Boost, the additions are applied to a class <code>basic_string</code> in 
a <code>boost</code> namespace that publicly inherits from <code>
std::basic_string</code>.</p>
<h3>Additional inserters and extractors for streams</h3>
<p>Add additional function templates to those in 27.7.3.6.4 [ostream.inserters.character],
<i>Character inserter function templates</i>, to cover the case where the 
argument character type differs from charT and is not <code>char</code>, <code>
signed char</code>, <code>unsigned char</code>, <code>const char*</code>, <code>
const signed char*</code>, or <code>const unsigned char*</code>.&nbsp; (The 
specified types are excluded because they are covered by existing signatures.) 
The semantics of the added signatures are the same as original signatures except 
that arguments shall be converted to the type and encoding of the stream.</p>
<p>Do the same for the character extractors in 27.7.2.2.3 [istream::extractors],
<i>basic_istream::operator&gt;&gt;</i>.</p>
<p>Do the same for the two <code>std::basic_string</code> inserters and 
extractors in 21.4.8.9 [string.io], <i>Inserters and extractors</i>.</p>
<h3>Iterator adapters for character type and encoding conversion</h3>
<h3>Narrow character and string types with UTF-8 encoding</h3>
<h3>Emulation of C++11 features for C++03 compilers and standard libraries</h3>
<p>These additions apply to Boost only. See header &lt;boost/interop/string11.hpp&gt;.</p>
<hr>
<p>&nbsp;</p>
<hr>
<p>© Copyright Beman Dawes 2011</p>
<p>Revised 
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->02 November 2011<!--webbot bot="Timestamp" endspan i-checksum="39624" --></p>
<p>&nbsp;</p>

</body>

</html>